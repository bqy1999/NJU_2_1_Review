#计算机系统基础

##计算机系统概述

###冯诺伊曼结构主要思想

1. 世界上第一个计算机ENIAC
2. 冯诺伊曼结构最重要的思想是**“存储程序”**工作方式
3. 冯诺伊曼结构
   1. 应该有个**主存**，用来存放程序和数据
   2. 应该有个**自动逐条取出指令**的部件
   3. 还应该有具体**执行指令**（即运算）的部件
   4. 程序由指令构成
   5. 指令描述如何对数据进行处理
   6. 应该有将程序和原始数据**输入**计算机的部件
   7. 应该有将运算结果**输出**计算机的部件
4. 冯诺伊曼结构的主要思想
   1. 计算机应由运算器、控制器、存储器、输入设备和输出设备五个基本部件组成；
   2. 各基本部件的功能是：
      - **存储器**不仅能存放数据，而且也能存放指令，形式上两者**没有区别**，但计算机应**能区分**数据还是指令；
      - **控制器**应能**自动取出指令**来执行；
      - **运算器**应能进行加/减/乘/除四种基本算数运算，而且也能进行一些逻辑运算和附加运算；
      - 操作人员可以通过**输入设备**、**输出设备**和主机进行通信。
   3. 内部以**二进制表示**指令和数据。每条指令由操作码和地址码两部分组成。操作码指出操作类型，地址码指出操作数的地址。由一串指令组成程序。
   4. 采用**“存储程序”**工作方式。

### 现代计算机结构模型及工作原理

1. 认识计算机最基本的部件
   1. CPU：中央处理器
   2. PC：程序计数器
   3. MAR：存储器地址寄存器
   4. ALU：算术逻辑部件
   5. IR：指令寄存器
   6. MDR：存储器数据寄存器
   7. GPRs：通用寄存器组（由若干通用寄存器组成，早期就是累加器）
2. 计算机是如何工作的？
   1. 程序在执行前：数据和指令**事先存放**在存储器中，每条指令和每个数据都有地址，指令**按序存放**，指令由OP、ADDR字段组成，程序起始地址置PC；
   2. 开始执行程序：
      - 第一步：根据PC取指令
      - 第二步：指令译码
      - 第三步：取操作数
      - 第四步：指令执行
      - 第五步：回写结果
      - 第六步：修改PC的值，继续执行下一条指令
3. 指令和数据
   1. 指令中需给出的信息
      - 操作性质（操作码）
      - 原操作数1 或/和 原操作数2（立即数、寄存器编号、**存储地址**）
      - 目的操作数地址（寄存器编号、**存储地址**）
      - 存储地址的描述与**操作数的数据结构**有关！

### 从机器语言到高级汇编语言

1. 用机器语言编写程序，并记录在纸带或卡片上
2. 用汇编语言开发程序
   1. 用助记符表示操作码
   2. 用标号表示位置
   3. 用助记符表示寄存器
3. 用高级语言开发程序
   1. 它们与具体机器结构无关
   2. 面向算法描述，比机器级语言描述能力强的多
   3. 高级语言中一条语句对应几条、十几条甚至几百条指令
   4. 有“面向过程”和“面向对象”的语言之分
   5. 处理逻辑氛围三种结构
      - 顺序结构、选择结构、循环结构
   6. 有两种转换方式：“编译”和“解释”
      - 编译程序（Complier）：将高级语言源程序转换为机器级目标程序，执行时自动启动目标程序即可；
      - 解释程序（Interpreter）：将高级语言语句逐条翻译成机器指令并执行，不生成目标文件。

### 程序的开发和执行及其支撑环境

1. 不同层次语言之间的等价转换
   - 高级语言源程序 --(编译程序)--> 汇编语言源程序 --(汇编程序)--> 机器语言目标程序 --(指令译码器)--> 控制信号
2. 开发和运行程序的支撑
   1. 早期：直接输入指令和数据，启动后把第一条指令地址送PC开始执行
   2. 高级语言开发
      - 需要编辑器编写源程序
      - 需要翻译转换软件处理各类源程序
        - 编译方式：预处理程序、编译器、汇编器、链接器
        - 解释方式：解释程序
      - 需要一个可以执行程序的界面（环境）
        - GUI方式：图形用户界面
        - CUI方式：命令行用户界面
   3. 支撑程序开发和运行的环境由系统软件提供，最重要的系统软件是**操作系统**和**语言处理系统**

###编程语言和计算机系统层次

1. 早期计算机系统的层次
   - 最早的计算机用机器语言编程（1GL）
     - 应用程序
     - 指令集体系结构
     - 计算机硬件
   - 后来用汇编语言编程（2GL）
     - 应用程序
     - 汇编程序
     - 操作系统
     - 指令集体系结构
     - 计算机硬件
2. 现代计算机系统的层次
   - 现代计算机用高级语言编程（过程式语言3GL，非过程化语言4GL）
     - 应用程序
     - 语言处理系统（包括各种语言处理程序（如编译、汇编、链接）、运行时系统（如库函数，调试、优化等功能））
     - 操作系统
     - 指令集体系结构
     - 计算机硬件

### 现代计算机系统的层次结构

1. 计算机系统的不同用户
   - 最终用户工作在由应用程序提供的最上面的抽象层
   - 系统管理员工作在由操作系统提供的抽象层
   - 应用程序员工作在语言处理系统（主要有编译器和汇编器）的抽象层
   - 语言处理系统建立在操作系统之上
   - 系统程序员（实现系统软件）工作在ISA层次，必须对ISA非常了解
   - 编译器和汇编器的目标程序由机器级代码组成
   - 操作系统通过指令直接对硬件进行编程控制
   - ISA处于软件和硬件的交界面（接口）
2. 指令集体系结构
   - ISA即指令集体系结构，有时简称为指令系统
   - ISA时一种规约，它规定了如何使用硬件
     - 可执行的**指令的集合**，包括**指令格式**，**操作种类**以及**每种操作对应的操作数**的相应规定；
     - 指令可以接受的**操作数的类型**；
     - 操作数所能存放的寄存器组的结构，包裹每个寄存器的名称、编号、长度和用途；
     - 操作数所能存放的**存储空间的大小和编址方式**；
     - 操作数在存储空间存放时按照大端还是小端方式存放；
     - 指令获取操作数的方式，即**寻址方式**；
     - 指令执行过程的控制方式，包括程序计数器（PC）、条件码定义等。

### 课程内容概要

- 数据的表示
- 数据的运算
- 各类语句的转换与表示（指令）
- 各类复杂数据结构的转换表示
- 过程（函数）调用的转换表示
- 链接（linker）和加载
- 程序执行（存储器访问）
- 异常和中断
- 输入输出（I/O）

## 数据的表示和存储

### 10进制数和2进制数

- 机器级数据分为两大类
  - 数值数据：无符号整数、带符号整数、浮点数（实数）
  - 非数值数据：逻辑数（包括位串）、西文字符和汉字
- 计算机内部所有信息都用二进制进行编码
- 用二进制编码的原因
  - 制造两个稳定态的物理器件容易
  - 二进制编码、技术、运算规则简单
  - 正好与逻辑命题真/假对应，便与逻辑运算
  - 可方便地用逻辑电路实现算数运算
- 真值和机器数
  - 机器数：用0和1编码的计算机内部的0/1序列
  - 真值：真正的值，即：现实中带正负号的数

1. 数值数据的表示
   - 数值数据表示的三要素
     - 进位计数制
     - 定、浮点表示
     - 如何用二进制编码
   - 进位计数制
     - 十进制、二进制、十六进制、八进制数及其相互转换
   - 定/浮点表示（解决**小数点**位置）
     - 定点整数、定点小数
     - 浮点数（可用一个定点小数和一个定点整数来表示）
   - 定点数的编码（解决**正负号**问题）
     - 原码、补码、反码、移码（反码很少用）

### 2，8，10，16进制数之间的转换

八进制/十六进制时二进制的简便表示。便于阅读和书写

1. 进制转换
   - R进制数 => 十进制数
     - 按“权”展开
   - 十进制数 => 二进制数，再将二进制转换为16进制或8进制
     - 整数部分和小数部分分别转换
     - 整数—— “除基取余，上右下左”
     - 小数—— “乘基取整，上左下右”

2. 定点数和浮点数
   - 计算机中只能通过**约定小数点**的位置来表示
     - 小数点位置约定在固定位置的称为**定点数**
     - 小数点位置约定为可浮动的数称为**浮点数**
   - 定点小数用来拜师浮点数的尾数部分
   - 定点整数用来表示整数，分**带符号整数**和**无符号整数**
   - 任何实数：$X=(-1)^{s}\times M\times R^{E}$
     - 其中$S$取值为0或1，用来决定$X$的符号；
     - $M$是一个二进制定点小数，称为**数$X$的尾数**；
     - $E$是一个二进制定点整数，称为**数$X$的阶或指数**；
     - $R$时基数，可以为2、4和16等

### 原码和移码表示

1. 原码表示（“正”号用0表示，“负”号用1表示，数值部分不变！）

   - 浮点数的尾数$M$用原码定点小数表示

2. 移码表示（将每一个数值加上一个偏置常数）

   - 0的移码表示唯一

   - 浮点数的阶$E$用移码表示

### 模运算系统和补码表示

1. 补码-模运算
   1. 重要概念：在一个模运算系统中，一个数与它除以“模”后的余数等价
2. 结论1: 对于某一确定的模，某数减去小于模的另一数，总可以用该数加上另一数负数的补码来表示
3. 结论2: 一个**负数**的补码等于将**对应正数**补码**各位取反、末位加一**
4. 结论3: 正数的补码是它本身

### 补码和真值的对应关系

1. 32位机器中机器数占的位

   1. int型32位
   2. short型16位
   3. char型8位

2. 变形补码的表示

   1. 补码定义：$[X]_{补} = 2^{n}+X (-2^{n}\leq X < 2^{n}, mod 2^{n})$
      1. 正数：符号位为0，数值部分不变
      2. 负数：符号位为1，数值部分“各位取反，末位加1”
   2. 变形**（4's）**补码：双符号位，用于存放可能溢出的中间结果

3. 求真值的补码

   ​	简便方法：负数，从右向左遇到第一个1的前面各位取反

4. 求补码的真值

   - 令：$[A]_{补} = a_{n-1}a_{n-2}\cdots a_{1}a_{2}$
   - 公式：$A = -a_{n-1}\cdot 2^{n-1}+a_{n-2}\cdot 2^{n-2}\cdots a_{1}\cdot 2^{1} + a_{0}\cdot 2^{0}$
   - 简便方法：
     - 符号为0，则为正数，数值部分相同
     - 符号为1，则为负数，数值各位取反，末位加一

### 无符号整数和带符号整数

1. 无符号整数
   - 机器中字的为排列顺序有两种方式
     - 高到低位从左到右
     - 高到低位从右到左
   - 一般在全部是正数运算切不出现负值结果的场合下，可使用无符号数表示。例如，地址运算，编号表示，等等
   - 无符号整数中的编码中没有**符号位**
   - 能表示的最大值大于位数相同的带符号整数的最大值
2. 带符号整数（计算机中带符号数都用补码表示 ）
   - 计算机必须能处理正数和负数
   - 有三种定点编码方式
     - Signed and magnitude（原码）	定点小数，用来表示浮点数的尾数
     - Excess（biased） notion（移码） 定点整数，用来表示浮点数的阶
     - Two's complement（补码）            50年代以来，所有计算机都用补码来表示带符号整数

### 浮点数的表示范围

1. 科学技术法与浮点数
   - 规格化形式：小数点前只有一位非0数
2. 浮点数的表示范围
   - 最大正数：$(1-2^{-24})\times 2^{127}$
   - 最小正数：$(1/2)\times 2^{-128}$

### IEEE754中规格化数的表示

1. IEEE754标准
   1. 单精度
      - Sign bit：1表示negative；0表示positive
      - Exponent（阶码）：用移码来表示（全0和全1用来表示特殊值）
        - SP规格化阶码范围为00000001（-126）～ 11111110（127）
        - bias为127（single），1023（double）
      - Significant（部分尾数）：
        - 规格化尾数最高最总是1，所以隐含表示。省1位
        - 1+23bits（single），1+52bits（double）

### IEEE754中特殊数的表示

1. 0的机器数表示
   - 阶码：全0
   - 尾数：全0
2. $+\infty / -\infty$的机器数表示
   - 阶码：全1
   - 尾数：全0
     - 正负无穷大仅符号位不同
3. “非数”的表示
   - 阶码：全1
   - 尾数：nonzero
4. 当输入数据是一个不可表示数时，机器将其转换为最近的可表示数

### 非数值数据的编码表示

1. 逻辑数据的编码表示
   - 表示
     - 用一位表示。$N$为二进制数（位串）可表示$N$个逻辑数据
   - 运算
     - 按位进行。如，按位与/按位或/逻辑左移/逻辑右移 等
   - 识别
     - 逻辑数据和数值数据在形式上并无差别，也是一串0/1序列，计算机靠指令来识别。
2. 西文字符的编码表示
   - 特点
     - 是一种拼音文字，用有限几个字母可拼写出所有单词
     - 只需对有限个字母和数学符号、标点符号等辅助字符编码
     - 所有字符总数不超过256个，使用7或8个二进位可表示
   - 表示
     - 十进制数字：$0/1/2/\cdots / 9$
     - 英文字母：$A/B/\cdots /Z/a/b/\cdots/z$
     - 专用符号：$+/-/\%/*/\&/\cdots$
     - 控制字符（不可打印或显示）
   - 操作
     - 字符串操作，如：传送/比较 等
3. 汉字及国际字符的编码表示
   - 汉字特点
     - 汉字是表意文字，一个字就是一个方块图形
     - 汉字数量巨大
   - 编码形式
     - 输入码：对汉字用相应案件进行编码表示，用于输入
     - 内码：用于在系统进行存储、查找、传送等处理
     - 字模点阵或轮廓描述：描述汉字字模点阵或轮廓，用于显示/打印
4. 多媒体信息的表示
   - 图形、图像、音媒、视频等信息在机器内部也用0和1表示
     - 图形用构建图形的直线或曲线的坐标点及控制点来描述
     - 图像用构成图像的点的亮度、颜色或会读等信息描述
     - $\cdots$

### 数据宽度和存储容量的单位

1. 数据的基本宽度
   - 比特（bit，位）是计算机中处理、存储、传输信息的最小单位
   - 二进制信息最基本的计量单位是“字节”
     - 现代计算机中，存储器按字节编址
     - 字节是最小可寻址单位
     - 如果以字节为一个排列单位，则LSB表示最低有效字节
   - 除位和字节外，还经常使用“字”作为单位
     - “字”和“字长”的概念不同
       - “字长”指**数据通路的宽度**
       - “字长”等于CPU内部总线的宽度、运算器的位数、通用寄存器的宽度
       - “字”表示被处理信息的单为，用来度量数据类型的宽度
       - 字和字长的宽度可以是一样的，也可以不同
2. 数据量的度量单位
   - 存储二进制信息时的度量单位要比字节或字大得多
   - 容量经常使用的单位有：
     - 千字节（KB）
     - 兆字节（MB）
     - 千兆字节（GB）
     - 兆兆字节（TB）
   - 通信中的带宽使用的单位有：
     - 千比特/秒
     - 兆比特/秒
     - 千兆比特/秒
     - 兆兆比特/秒
3. 程序中数据类型的宽度
   - 高级语言支持多种不同类型和不同长度的数据
   - 必须确定相应的机器级数据表示方式和相应的处理指令

### 数据存储时的字节排列

1. 数据的存储和排列方式
   - 大端方式（Big Endian）：MSB所在的地址是数的地址
   - 小段方式（Little Endian）：LSB所在的地址是数的地址

## 程序的执行和存储访问

### 程序执行概述引言

### 程序和指令的关系

1. 程序及指令的执行过程
   - 程序和指令的关系
     - 程序由一条一条指令组成，指令按顺序存放在内存连续单元
   - 程序的执行：**周而复始地执行一条一条指令**
     - 正常情况下，指令按其存放顺序执行
     - 遇到需要改变程序执行流程时，用相应的转移指令（包括无条件转移指令、条件转移指令、调用指令和返回指令）来改变程序执行流程
   - 程序的执行流的控制
     - 将要执行的指令所在的存储单元的地址由程序计数器PC給出，通过改变PC的值来控制执行顺序
   - 指令周期：**CPU取出并执行一条指令的时间**

### 一条指令的执行过程

1. 程序及指令的执行过程
   - 计算指令地址
   - 取指令（$PC+``1"$）
   - 操作码译码
   - 主存地址运算
   - 取操作数
   - 数据操作（进行算数/逻辑运算）
   - 操作数地址计算
   - 存操作数
   - 下一条指令
   - 以上每步都需检测“异常”，若有异常，则自动切换到异常处理程序
   - 检测是否用“中断”请求，有则转中断处理
2. CPU运行的过程就是执行一条一条指令的过程
3. CPU执行指令的过程中，包含**CPU操作**、**访问内存或I/O端口的操作**两类
4. 机器指令的执行过程
   - 取指令：从PC所指单元取出指令送指令寄存器（IR），并增量Pc
   - 指令译码：不同指令其功能不同，因而需要不同的操作控制信号
   - 原操作数地址计算并取操作数
   - 执行数据操作
   - 目的操作数地址计算并存结果
   - 指令地址计算并将其送PC

### IA-32指令的大致执行过程

1. 机器指令的执行过程
   - 四种基本操作
     - 读取某一主存单元的内容，并将其装入某个寄存器
     - 把一个数据从某个寄存器存入给定的主存单元中
     - 把一个数据从某寄存器送到另一寄存器或ALU中
     - 进行算数或逻辑运算
2. 保护模式下的寻址方式
   - 立即寻址：指令直接给出操作数
   - 寄存器寻址：指定的寄存器R的内容为操作数
   - 位移：$LA = (SR)+A$
   - 基址寻址：$LA = (SR)+(B)$
   - 基址加位移：$LA = (SR)+(B) + A$
   - 比例变址加位移：$LA = (SR)+(I)\times S+A$
   - 基址加变址加位移：$LA=(SR)+(B)+(I) + A$
   - 基址加比例变址加位移：$LA=(SR)+(B)+(I)\times S + A$
   - 相对寻址：$LA = (PC)+A$

### CPU的基本功能与结构

### 主存储器组织概述

### 访存操作和基本术语

1. 基本术语
   - 记忆单元（存储基元/存储元/位元）（Cell）
     - 具有两种稳态的能够表示二进制数码0和1的物理器件
   - 存储单元/编址单位（Addressing Unit）
     - 具有相同地址的位构成一个存储单元，也称为一个编址单位
   - 存储体/存储矩阵/存储阵列（Bank）
     - 所有存储单元构成一个存储阵列
   - 编址方式（Addressing Mode）
     - 字节编址、按字编址
   - 存储器地址寄存器
     - 用于存放主存单元地址的寄存器
   - 存储器数据寄存器
     - 用于存放主存单元中的数据的寄存器

### 存储器分类

1. 存储器分类

   （1） 按工作性质/存取方式分类：

   - 随机访问存储器（RAM）
     - 每个单元读写时间一样，且与各单元所在位置无关。如：内存
   - 顺序存取存储器（SAM）
     - 数据按顺序从存储载体的始端读入或写出，因而存取时间的长短与信息所在位置有关。例如：磁带。
   - 直接存取存储器（DAM）
     - 直接定位到读写数据块，在读写数据块时按顺序进行。例如：磁盘。
   - 相联存储器（AM/CAM）
     - 按内容检索到存储位置进行读写。例如：块表。

   （2）按存储介质分类：

   - 半导体存储器
   - 磁表面存储器
   - 光存储器

   （3）按信息的可更改性分类：

   - 读写存储器：可读可写
   - 只读存储器：只能读不能写

   （4）按断电后信息的可保存性分类：

   - 非易失（不挥发）性存储器（Nonvolatile Memory）
     - 信息可一直保留，不需电源维持。
   - 易失（挥发）性存储器（Volatile Memory）
     - 电源关闭时信息自动丢失

   （5）按功能/容量/速度/所在位置分类

   - 寄存器（Register）
     - 封装在CPU内
   - 高速缓存（Cache）
   - 内存储器（MM）
   - 外存储器（AM）

### 主存的基本结构（较少考）

1. 8个cell构成一个存储单元（8个单元拥有同样的地址）
2. $n$位地址线对应的存储单元的个数是$2^{n}$

### 主存的性能指标

1. 性能指标
   - 按字节连续编址，每个存储单元位1个字节（8个二进位）
   - 存储容量：所包含的存储单元的总数（单位：MB或GB）
   - 存取时间$T_{A}$：从CPU送出内存单元的地址码开始，到主存读出数据并送到CPU（或者是把CPU数据写入内存）所需要的时间，分**读取时间**和**写入时间**
   - 存储周期$T_{MC}$：连续两次访问存储器所需的最小时间间隔，它应等于存取时间加上下一次存取开始前所要求的附加时间，因此，$T_{MC}$比$T_{A}$大（因为存储器由于读出放大器、驱动电路等都有一段稳定恢复时间，所以读出后不能立即进行下一次访问。）

### 半导体RAM的组织

1. 记忆单元（Cell）-> 存储器芯片（Chip）-> 内存条（存储器模块）
2. 存储体（Memory Bank）：由记忆单元（位元）构成的存储阵列
3. 记忆单元的组织：
   - 字片式存储体阵列组织
   - 位片式存储体阵列组织

### PC中的内存条

1. 主存地址和片内地址有何关系？
   - 主存地址27位，片内地址24位，与高24位主存地址相同
2. 主存低3位地址的作用是什么？
   - 确定8个字节中的哪个，即用来选片

### 主存模块的连接与读写操作

### 磁盘存储器的结构（较少考）

### 磁盘启动器以及操作过程

1. 磁盘的操作流程如下：
   - 所有磁头同步寻道（由柱面号控制）->选择磁头（由磁头号控制）->被选中磁头等待扇区到达磁头下方（由扇区号控制）->读写该扇区中数据
   - 磁盘信息以扇区为单位进行读写，平均存取时间为：$T=平均寻道时间+平均旋转等待时间+数据传输时间$
     - 平均寻道时间：磁头寻找到指定次到所需平均时间
     - 平均等待时间

### 磁盘存储器的组成

1. 硬盘存储器的基本组成
   - 磁记录介质：用来保存信息
   - 磁盘驱动器：包括读写电路、读\写转换开关、磁头与磁头定位伺服系统等
   - 磁盘控制器：包括控制逻辑、时序电路、“并->串”转换和“串->并”转换电路等。（用于连接主机与盘驱动器）

### 磁盘存储器的连接与操作

1. 第一步
   - CPU对磁盘控制器初始化
     - 读命令
     - 磁盘逻辑块号
     - 主存起始地址
   - 然后启动磁盘驱动器工作
2. 第二步
   - 磁盘控制器读相应的扇区，并按DMA方式把数据送到主存
3. 第三步
   - 当DMA传送结束，磁盘控制器向CPU发送“DMA结束中断请求”，要求CPU进行相应的后处理

### 存储器层次结构概述

1. 己经了解的存储器：寄存器，SRAM，DRAM，硬盘

2. 单独使用某一种存储器，都不能满足我们的需要，采用**分层存储**结构来构建计算机的存储体系！

3. 层次化存储器结构（Memory Hierarchy）

   - **磁盘**和**主存**按page进行交换（4KB）

   - **主存**和**cache**按主存块进行交换

4. 局部性：

   - 时间局部性
     - 含义：刚被访问过的单元很可能不久又被访问
     - 做法：让最近被访问过的信息保留在靠近CPU的存储器中
   - 空间局部性
     - 含义：刚被访问过的单元的临近单元很可能不久被访问
     - 做法：将刚被访问过的单元的临近单元调到靠近CPU的存储器中

### 引入cache的出发点

程序具有局部性（时间局部性、空间局部性）

### Cache和主存的关系

### Cache操作过程

1. 若访问信息不在cache中，称为缺失（Miss）
2. 若访问信息在cache中，称为命中（Hit）

### 实现Cache需要解决的问题

1. AD所在的块是否在cache中
2. 如何从cache中取数据
3. 要实现Cache机制需要解决哪些问题？
   - 如何分块？
     - 主存被分成若干大小相同的块，称为**主存块（Block）**，Cache也被分成相同大小的块，称为**Cache行（Line）**或**槽（Slot）**。
   - 主存块和cache之间如何映射？
   - cache已满时，怎么办？
   - 写数据时怎样保证cache和主存的一致性
   - 如何根据主存地址访问到cache中的数据？

4. Cache对程序员是透明的

### 直接映射主存地址划分

1. 把主存的每一块映射到一个固定的Cache行（槽）
2. 也称为模映射（Module Mapping）
3. 映射关系为：
   - **Cache行号=主存块号 mod Cache行数**
4. 假定数据在主存和Cache间的传送单位为$512B​$。
   - cache大小：$16行\times 512B/行 =8KB=2^{13}B$
   - 主存大小：$2048块\times 512B/块 = 1MB = 2^{20}B$
   - 因为主存大小为$2^{20}B$，所以主存地址应该为20字节
   - 块群数：$\frac{2048}{16}=2^{7}$
   - Cache标记（tag）指出对应行取自哪一个主存块群，因为块群数为$2^{7}$，所以主存标记应该占据7位
   - 因为传送单位为$512B$，即块有512个单元，块的大小为$2^{9}=512B$，所以块内地址应该占据9位
   - 因此主存地址高11位为主存块号，低9位为块内地址
   - **主存地址：主存标记tag（7位）+Cache槽号index（4位）+块内地址（9位）**

### 有效位和访存过程

1. 有效位（Valid Bit）
   - $V$为有效位，为1表示信息有效，为0表示信息无效
   - 开机或复位时，使所有行的有效位$V=0$
   - 某行被替换后使其$V=1$
   - 某行新装入块时使其$V=1$
   - **通过使$V=0$来冲刷Cache**（例如：进程切换时，DMA传送时）
   - 通常为操作系统设置**“cache冲刷”**指令，因此，**cache对操作系统程序员不是透明的**

### Cache容量的计算

1. cache容量：$(1+tag+data)\times 2^{index}\ bits = (1+tag+data)\times 2^{index-3} B$

### 直接映射方式的特点

1. 特点：
   - 容易实现，命中时间短
   - 无需考虑淘汰（替换）问题
   - 但不够灵活，cache存储空间得不到充分利用，命中率低

### 全相联映射方式

1. **主存地址：组群号tag+块内地址**
2. 按内容访问，是相联存取方式

### 组相联映射方式

1. 组相联映射
   - 组相联映射结合直接映射和全相联映射的特点
   - 将cache所有行分组，把主存块映射到cache固定组的任一行中，也即：组间模映射，组内全映射。映射关系为：
     - cache组号 = 主存块号 mod cache组数
2. **主存地址：组群号tag+组号index+块内地址**
   - 与直接映射的区别：直接映射是**组群号tag+槽（行）号index+块内地址**

### cache命中率和缺失率

1. 命中率、缺失率、缺失损失
   - Hit：要访问的信息在Cache中
     - Hit Rate（命中率）：在Cache中的概率
     - Hit Time（命中时间）：在Cache中的访问时间，包括：判断时间+Cache访问
   - Miss：要找的信息不在Cache中
     - Miss Rate（缺失率）：1-（Hit Rate）
     - Miss Penalty（缺失损失）：访问一个主存块所花时间
2. 平均访问时间：$T_{ave} = T_{c}\times \alpha + (T_{c}+T_{M})\times (1-\alpha)$

### Cache的关联度

1. 高速缓存的缺失率和关联度
   - 三种映射方式：
     - 直接映射：唯一映射（只有一个可能的位置）
     - 全相联映射：任意映射（每个位置都可能）
     - $N-$路组相联映射：$N-$路映射（有$N$个可能的位置）
   - 关联度：一个主存块映射到cache中时，可能存放的位置个数

### 替换算法概述

1. 替换算法：
   - 常用的替换算法有：
     - 先进先出FIFO（first-in-first-out）
     - 最近最少用LRU（least-recently used）
     - 最不经常用LFU（least-frequently used）
     - 随即替换算法（Random）
     - 等等

### 先进先出（FIFO）算法

1. 总是把最先进入的那一块淘汰掉
2. **FIFO不是一种栈算法，即命中率并不随组的增大而提高。**

### 最近最少用（LRU）算法

1. 总是把最近最少用的那块淘汰掉
2. 替换算法-最近最少用
   - LRU是一种栈算法，它的命中率随组的增大而提高
   - 每一个槽加一个信息LRU位来记录这些主存块的使用情况
   - 计数器变化规则：
     - 以每组四行为例，计数器有2位。计数值越小则说明越被常用。
     - 命中时，被访问行的计数值置0，比其低的计数器加1，其余不变。
     - 未命中且该组未满时，新行计数器置为0，其余全加1。
     - 未命中且该组已满时，计数值为3的那一行的主存块被淘汰，新行计数器置为0，其余加1。

### 写策略概述

1. 写策略（Cache一致性问题）
   - 因为cache中的内容是主存块副本，需要保持一致性
2. 对于写命中，有两种处理方式：
   - **Write Through（通过式写、写直达、直写）**
     - 同时写Cache和主存单元
     - 坏处：速度较慢
     - 使用写缓冲（**Write Buffer**）
       - 在cache和memory之间加一个Write Buffer
         - CPU同时写数据到Cache和Write Buffer
         - Memory controller（存控）将缓冲内容写主存
       - Write Buffer（写缓冲）是一个先进先出队列
         - 一般有4项
         - 在存数频率不高时效果好
       - 最棘手的问题
         - 当频繁写时，易使写缓存饱和，发生阻塞
   - **Write Back（一次性写、写会、回写）**
     - 只写cache不写主存，缺失时一次写回，每行有一个修改位**（“dirty bit-脏位”）**，大大降低主存带宽需求，控制可能很复杂
3. 对于写不命中，有两种处理方式
   - **Write Allocate（写分配）**
     - 将主存块装入Cache，然后更新相应单元
     - 试图利用空间局部性，但每次都要从主存读一个块
   - **Not Write Allocate（非写分配）**
     - 直接写主存单元，不把主存块装入Cache

### 早期虚拟存储器的概念

